#include <stdio.h>

#define MAX_N 205
#define INF 1000000000

typedef struct {
    int n;
    int A[MAX_N][MAX_N];
} Graph;

int d[MAX_N];
int ES[MAX_N];
int LS[MAX_N];
int in_degree[MAX_N];
int out_degree[MAX_N];
int topo_order[MAX_N];

void init_graph(Graph *G, int n) {
    G->n = n;
    int i, j;
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            G->A[i][j] = 0;
        }
    }
}

void add_edge(Graph *G, int u, int v) {
    G->A[u][v] = 1;
}

int main() {
    Graph G;
    int n, u, v;
    int i;
    int queue[MAX_N];
    int head = 0, tail = 0;

    if (scanf("%d", &n) != 1) return 0;

    int alpha = n + 1;
    int beta = n + 2;
    int total_nodes = n + 2;

    init_graph(&G, total_nodes);
    
    for(i = 1; i <= total_nodes; i++) {
        in_degree[i] = 0;
        out_degree[i] = 0;
        d[i] = 0;
    }

    for (u = 1; u <= n; u++) {
        scanf("%d", &d[u]);
        do {
            scanf("%d", &v);
            if (v > 0) {
                add_edge(&G, v, u);
                in_degree[u]++;
                out_degree[v]++;
            }
        } while (v > 0);
    }

    for (u = 1; u <= n; u++) {
        if (in_degree[u] == 0) {
            add_edge(&G, alpha, u);
            in_degree[u]++;
            out_degree[alpha]++;
        }
    }

    for (u = 1; u <= n; u++) {
        if (out_degree[u] == 0) {
            add_edge(&G, u, beta);
            in_degree[beta]++;
            out_degree[u]++;
        }
    }

    for (i = 1; i <= total_nodes; i++) {
        if (in_degree[i] == 0) {
            queue[tail++] = i;
        }
    }

    int count = 0;
    while (head < tail) {
        int u_curr = queue[head++];
        topo_order[count++] = u_curr;

        for (int v_curr = 1; v_curr <= total_nodes; v_curr++) {
            if (G.A[u_curr][v_curr]) {
                in_degree[v_curr]--;
                if (in_degree[v_curr] == 0) {
                    queue[tail++] = v_curr;
                }
            }
        }
    }

    for (i = 1; i <= total_nodes; i++) ES[i] = 0;
    
    for (i = 0; i < count; i++) {
        int u_curr = topo_order[i];
        for (int v_curr = 1; v_curr <= total_nodes; v_curr++) {
            if (G.A[u_curr][v_curr]) {
                if (ES[u_curr] + d[u_curr] > ES[v_curr]) {
                    ES[v_curr] = ES[u_curr] + d[u_curr];
                }
            }
        }
    }

    int T_project = ES[beta];

    for (i = 1; i <= total_nodes; i++) LS[i] = INF;
    
    LS[beta] = T_project;

    for (i = count - 1; i >= 0; i--) {
        int u_curr = topo_order[i];
        
        if (u_curr == beta) continue;

        int min_val = INF;
        int has_succ = 0;
        
        for (int v_curr = 1; v_curr <= total_nodes; v_curr++) {
            if (G.A[u_curr][v_curr]) { 
                has_succ = 1;
                if (LS[v_curr] < min_val) {
                    min_val = LS[v_curr];
                }
            }
        }
        
        if (has_succ) {
             LS[u_curr] = min_val - d[u_curr];
        }
    }
    
    printf("%d\n", T_project);
    
    for (i = 1; i <= total_nodes; i++) {
        printf("%d-%d\n", ES[i], LS[i]);
    }

    return 0;
}
